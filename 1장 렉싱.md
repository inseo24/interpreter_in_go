## 1장 렉싱

### 어휘 분석

소스코드로 어떤 작업을 하려면 코드를 더 접근하기 쉬운 형태로 변환할 필요가 있다.

소스코드를 평가하기에 앞서 아래와 같이 두 단계에 걸쳐서 표현법을 바꾸려 한다.

소스코드 → 토큰 → 추상구문트리

첫 번째 변환 작업은 소스코드 → 토큰 열로 변환하는 것이다.

이런 작업을 ‘어휘 분석(lexical analysis)’ 혹은 ‘렉싱(lexing)’이라고 부른다. 이 변환 작업은 렉서(lexer)라는 녀석이 수행한다. 

토큰은 자체로 쉽게 분류할 수 있는 작은 자료구조다. 토큰을 파서에 입력하고 나면 두 번째 변환 작업이 일어난다. 파서는 전달받은 토큰열을 ‘추상구문트리(Abstract Syntax Tree)’로 바꾼다.

예시로 아래 내용을 렉서에 입력으로 넣는다.

```go
"let x = 5 + 5;"
```

그러면 렉서는 아래와 같은 결과물을 출력한다.

```go
[
	LET,
	IDENIFIER("x"),
	EQUAL_SIGN,
	INTEGER(5),
	PLUS_SIGN,
	INTEGER(5),
	SEMICOLON
]
```

모든 토큰에는 원본 소스코드 표현이 부착되어 있다. 그러나 정확히 토큰을 어떻게 구성할지는 렉서 구현에 따라 다르다. 예를 들어 어떤 렉서는 파싱 단계에서 ‘5’를 정수로 변환하는 정도에 그친다. 혹은 더 늦게 변환하거나 심지어 토큰 구성 시점에는 아예 변환하지 않는다.

눈여겨볼 것은 렉서가 공백문자를 토큰으로 만들지 않았다는 것이다. 공백은 그저 토큰 사이의 구분자일 뿐이다.

한편 파이썬처럼 공백의 길이가 중요한 언어도 있다. 이런 경우 렉서는 공백이나 줄 바꿈 문자를 그냥 먹어 치울 수(eat up) 없다. 렉서는 공백문자를 토큰으로 변환할 필요가 있는데, 나중에 파서가 공백 토큰을 보고 에러인지, 공백이 부족하거나 너무 많은지 등을 판단할 수 있어야 하기 때문이다.(공백의 중요 유무는 언어에 따라 달라질 수 있고 이는 언어의 렉서마다 다를 수 있다는 점!)

상용 렉서는 행 번호, 열 번호, 파일 이름 등을 토큰에 부착한다. 부착하는 이유는 이후에 수행될 파싱 단계에서 조금 더 쓸만한 에러 메시지를 출력하기 위해서다. 이 책에서는 이런 기능을 만들지 않을 건데 본질적인 간명함을 파악할 수 없을 수 있기 때문이다.

### 토큰 정의하기

첫 번째로 할 일은 렉서가 만드는 결과물인 토큰을 정의하는 것이다. 토큰을 몇 개 정의하는 것으로 시작해, 렉서가 확장할 때마다 토큰을 추가할 것이다.

필요한 토큰 타입

1. 정수 타입 등의 숫자 토큰 타입
2. 식별자
3. 특수문자

token.go 작성

```go
package token

type TokenType string

type Token struct {
	Type    TokenType
	Literal string
}

const (
	// 특수 타입
	ILLEGAL = "ILLEGAL" // 렉서가 어떤 토큰이나 문자를 알 수 없을 때
	EOF     = "EOF"     // EOF : End Of File, 파일의 끝. 파서에게 이만 멈춰도 좋다~라고 얘기하는 용도.

	// 식별자 + 리터럴
	IDENT = "IDENT" // add, foobar, x, y ...(identifier)
	INT   = "INT"

	// 연산자
	ASSIGN = "="
	PLUS   = "+"

	// 구분자
	COMMA     = ","
	SEMICOLON = ";"

	LPAREN = "("
	RPAREN = ")"
	LBRACE = "{"
	RBRACE = "}"

	// 예약어
	FUNCTION = "FUNCTION"
	LET      = "LET"
)
```